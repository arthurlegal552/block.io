<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>FPS com Controle e Ch√£o</title>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
  </script>
</head>
<body style="margin:0; overflow:hidden;">
<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// üîß Cena, c√¢mera e renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,1.6,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// üåû Ilumina√ß√£o
scene.add(new THREE.AmbientLight(0xffffff,0.5));
const dir = new THREE.DirectionalLight(0xffffff,0.8);
dir.position.set(5,10,7);
scene.add(dir);

// üß± Ch√£o com textura repetida
const floorTex = new THREE.TextureLoader().load('floor.jpg');
floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
floorTex.repeat.set(10,10);
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(100,100),
  new THREE.MeshStandardMaterial({map:floorTex})
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// üì¶ Controles FPS + WASD
const controls = new PointerLockControls(camera, renderer.domElement);
scene.add(controls.getObject());
document.body.addEventListener('click', () => controls.lock());

const movement = {forward:false,back:false,left:false,right:false};
document.addEventListener('keydown', e => {
  switch(e.code) {
    case 'KeyW': movement.forward = true; break;
    case 'KeyS': movement.back = true; break;
    case 'KeyA': movement.left = true; break;
    case 'KeyD': movement.right = true; break;
  }
});
document.addEventListener('keyup', e => {
  switch(e.code) {
    case 'KeyW': movement.forward = false; break;
    case 'KeyS': movement.back = false; break;
    case 'KeyA': movement.left = false; break;
    case 'KeyD': movement.right = false; break;
  }
});

// üéÆ Modelo de bra√ßos animados
let mixer;
new GLTFLoader().load('./ct_fps_hand_for_roblox.glb', gltf => {
  const arms = gltf.scene;
  arms.position.set(0,-1.5,-0.5);
  arms.rotation.y = Math.PI;
  camera.add(arms);
  mixer = new THREE.AnimationMixer(arms);
  if (gltf.animations.length) {
    mixer.clipAction(gltf.animations[0]).play();
  }
});

// ‚è±Ô∏è Anima√ß√£o com clock
const clock = new THREE.Clock();
const speed = 5; // unidades por segundo

function animate() {
  const dt = clock.getDelta();

  // atualiza√ß√£o do mixer
  if (mixer) mixer.update(dt);

  // movimenta√ß√£o FPS
  if (controls.isLocked) {
    const dir = new THREE.Vector3();
    if (movement.forward) dir.z -= 1;
    if (movement.back) dir.z += 1;
    if (movement.left) dir.x -= 1;
    if (movement.right) dir.x += 1;

    if (dir.length()) {
      dir.normalize().applyQuaternion(camera.quaternion);
      controls.getObject().position.addScaledVector(dir, speed * dt);
    }
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// üîß Responsividade
window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
